Header.vue

/* 我想通过父元素来设置左右padding来将元素向内挤到正确位置,就必须先设置box-sizing盒模型!!! */
当页面出现滚动条时,就该思考一下,是不是没处理盒模型从而导致出现的问题!!!
    box-sizing border-box
    padding 0 15px 0 15px

/* 当不传入左右插槽内容时,不单独设置居中样式时,页面失效
此时需要将排除flex对其位置影响的的元素设置为绝对定位,使其脱离文档流后再进行定位处理 */
.header_title 
    width 30%
    position absolute
    left 50%
    transform translateX(-50%)

/* 直接调用函数,在严格模式下,this为undefined; 在非严格模式下this为window */

浏览器默认最小字体12px
我们可以通过transform scale(.8) 设置更小的字体

通过img, script等标签发送跨域请求
/* 通过ref属性修改该src值, 同时通过script标签发送请求处理兼容IE时,需要加上 时间戳 */
    this.$refs.captcha.src = 'http://localhost:4000/captcha?time=' + Date.now()

## 阻止表单的默认提交事件方法:
<!-- 按钮button 需要组织表单默认行为, 给div img 等非form标签添加的点击事件 则不需要添加阻止默认行为 -->
1. 将<input>标签内按钮类型从type="submit"修改为type=“button”
2. 表单内的<button>未指定类型时，默认的类型为submit，可以显式的修改为<button type="button">来阻止表单提交
3. 利用preventDefault()方法：
function func(event){
    event.preventDefault();
}
```
<form action="">
	<!--必须是input标签，button标签无效-->
    <input type="submit" value="按钮" onclick="func(event)" /> 
</form>
```

4. 用onclick点击事件来return false
function func(){
	return false;
}
```
<form action="">
	<!--必须是input标签，button标签无效-->
    <input type="submit" value="button" onclick="return func()" /> 
    <!--注意是onclick内是return func();而不是简单的调用func()函数-->
</form>
```
————————————————
版权声明：本文为CSDN博主「furfur-jiang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_44523860/article/details/109138113

组件中不要保留空options选项会报错 如:
mouthed: {

}


## Unexpected end of input 可以翻译为 “意外的终止输入”

它通常表示浏览器在读取我们的javascript代码时，碰到了不可预知的错误，导致浏览器无法进行下面的解析

一般**“ ”（双引号）， ‘ ’（单引号） ，{}，[]**未成对输入时会出现这样的错误
————————————————
版权声明：本文为CSDN博主「一个菜鸟的前端之路」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/hl18730262380/article/details/83032556

<!-- 解决问题思路 -->
设置国际化时制定新的语言, 切换按钮没有自动切换,那说明问题应该是 没有修改成功;
虽然localStorage中已保存成功,,那只能说明存储语句没有问题!!
事实上我的保存语句 少写了个e 哭死 this.$i18n.local
this.$i18n.locale = locale;


## Header组件
header子组件设置主要的样式, 比如在整体样式;
由于组件是在父组件中进行解析,所以 在父组件中也需要添加专用class设置相应的样式, 配合子组件中的整体样式

## iconfont图标微调整至每一个图标的位置, 借用原有两个class 名,
.iconfont
    position absolute
.icon-order-s
    top 5px
    font-size 32px
    color #02a774
.icon-vip
    top 9px
    margin-left 5px
    font-size 22px
    color #f90

# shop.vue goods.vue

## 通过伪类设置小三角
::after 
    content ''
    border 4px solid #000
    border-right none
    border-color transparent transparent transparent rgba(0, 0, 0, .67)
    position absolute   // 变为块元素起决定性因素
    top 2px
    left 48px   


## 背景遮罩层!!!!!!!!!!!!!!!!!!
使用时: 遮罩层上方的主包裹容器也必须是 绝对定位!!!!
.同级爸爸
    position absolute 
.同级遮罩层
    position absolute                   // 背景这招层
    top 0
    right 0
    left 0
    bottom 0
    background-color rgba(0, 0, 0, .5)

## 列表中子元素激活时,样式设置思路
例如文字:
子元素继承的样式优先级最低,所以给他的父元素设置统一样式, 激活时单独设置字体大小即可 
    font-size 12px 


## 确定视口中实现滚动条!!!!!!
父元素绝对定位,bottom等于确定值,overflow为hidden, display: flex很关键; 
子元素只需要高度大于父元素, overflow auto即可实现
父元素
    position absolute
    top 224px
    width 100%
    bottom 0
    overflow hidden        // 父元素定高后剪裁处理       

子元素
    width 100%
    height 100%            // 子元素必须设置特定高度,且你内部由内容城启动的高度高于子元素设置的高度!!!
    overflow auto

## flex布局中子元素款独家计算问题
要什么自行车!!! flex布局中,当然要通过flex自身的宽度自适应来解决宽度问题啊!!! 
父元素
    display flex
子元素1
    flex 1                       // 剩余空间占1份
    // width calc(100%-84px)     // 失效状态
子元素2
    flex 2                       // 剩余空间占2份
    // width calc(100%-84px)     // 失效状态
子元素3
    width 80px                   // 定宽

## 列表项设置通告技巧
所有项都设置正padding-bottom,则最后一个多出一个正padding-bottom的值;
此时通过设置margin-bottom为0使最后一个子元素抵消每个子元素设置的padding-bottom所带来的影响!!!
.food-item 
    display flex 
    margin 18px
    margin-left 0
    position relative
    padding-bottom 18px         // 要点
    &:not(:last-child)          // 排除法
        bottom-border-1px(rgba(7, 17, 27, 0.1))
    &:last-child                
        margin-bottom 0         // 通过设置margin-bottom为0使每一类的最后一个子元素抵消每个子元素设置的padding-bottom

##  每次设置border padding 时就要考虑是否需要更改盒模型!!!! box-sizing

## 设计浮动两列布局时, 当一侧为文字时,要测试,多文字换行时是否对左侧元素宽度产生致命影响
此时可以通过设置 flex: none 来使得某一子元素不再受浮动对其尺寸产生的影响!!!!

## 箭头函数简写错误导致的bug
错误省略写法: 需要把大括号 {} 和 return 同时省略
return tops.findIndex((top, index) => { scrollY >= top && scrollY < tops[index+1] } )
                
正确写法:
return tops.findIndex((top, index) => scrollY >= top && scrollY < tops[index+1])
